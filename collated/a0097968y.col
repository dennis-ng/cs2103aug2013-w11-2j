//@author: a0097968y



	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\DbController.java
	 */

package typetodo.db;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.TreeMap;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.joda.time.DateTime;
import org.joda.time.LocalDate;

import typetodo.exception.DuplicateKeyException;
import typetodo.exception.InvalidDateRangeException;
import typetodo.exception.MissingFieldException;
import typetodo.model.DeadlineTask;
import typetodo.model.FloatingTask;
import typetodo.model.Task;
import typetodo.model.TaskType;
import typetodo.model.TimedTask;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;

public class DbController {

	// Constants
	private static final String DIRECTORY_NAME = "savedfiles";
	private static final String FILENAME_TASK = "tasks.txt";
	private static final String FILENAME_PROPERTIES = "properties.txt";
	private static final String EXCEPTION_MSG_DUPLICATE_ID = "Task with the same id already exist.";
	private static final String EXCEPTION_MSG_INVALID_DATE_RANGE = "End time is earlier than start time.";
	private static final String EXCEPTION_MSG_MISSING_ID = "The task did not contain a taskId.";

	// Variables
	private HashMap<String, File> allFiles;
	private HashMap<String, String> properties;
	private TreeMap<Integer, Task> tasksCache;

	// Controllers and external libraries
	private static DbController mainDbHandler;
	private final Gson gson;
	private static Logger logger;
	private static FileHandler logFileHandler;

	private DbController() throws IOException, JsonSyntaxException {
		initializeLogger();
		gson = initializeGson();
		tasksCache = new TreeMap<Integer, Task>();
		properties = new HashMap<String, String>();
		initializeFiles();
		reloadAllFiles();
	}

	public static DbController getInstance() throws IOException,
			JsonSyntaxException {
		if (mainDbHandler == null) {
			mainDbHandler = new DbController();
		}
		return mainDbHandler;
	}

	private void initializeLogger() {
		logger = Logger.getLogger(DbController.class.getName());
		try {
			logFileHandler = new FileHandler("error.log", false);
		} catch (SecurityException | IOException e) {
			e.printStackTrace();
		}
		logger = Logger.getLogger(this.getClass().getName());
		logFileHandler.setFormatter(new SimpleFormatter());
		logger.addHandler(logFileHandler);
		logger.setLevel(Level.INFO);
	}

	private Gson initializeGson() {
		GsonBuilder gsonBuilder = new GsonBuilder();
		gsonBuilder.registerTypeAdapter(Task.class, new TaskAdapter());
		gsonBuilder.registerTypeHierarchyAdapter(DateTime.class,
				new DateTimeTypeAdapter());
		return gsonBuilder.setPrettyPrinting().create();
	}

	public void reloadAllFiles() throws JsonSyntaxException, IOException {
		for (String fileName : allFiles.keySet()) {
			this.loadFile(fileName);
		}
	}

	private void initializeFiles() throws IOException {
		allFiles = new HashMap<String, File>(3);
		final File subdirectory = new File(DIRECTORY_NAME);
		File FILE_TASKS = new File(subdirectory, FILENAME_TASK);
		File FILE_PROPERTIES = new File(subdirectory, FILENAME_PROPERTIES);
		allFiles.put(FILENAME_TASK, FILE_TASKS);
		allFiles.put(FILENAME_PROPERTIES, FILE_PROPERTIES);
		if (!subdirectory.exists()) {
			subdirectory.mkdir();
			for (File file : allFiles.values()) {
				file.createNewFile();
			}
		}
	}

	/**
	 * @throws IOException
	 *           During loadFile, if directory exist but file does not
	 * @throws JsonSyntaxException
	 *           contents of the file to load is incorrect
	 */
	private void loadFile(String fileName) throws JsonSyntaxException,
			IOException {
		StringBuilder fileToTextBuffer = new StringBuilder();
		File fileToLoad = allFiles.get(fileName);
		BufferedReader reader;
		try {
			reader = new BufferedReader(new FileReader(fileToLoad));
			String nextLine;
			while ((nextLine = reader.readLine()) != null) {
				fileToTextBuffer.append(nextLine);
			}
			reader.close();
		} catch (IOException e) {
			logger.log(Level.SEVERE, e.toString());
			throw e;
		}
		if (!fileToTextBuffer.toString().isEmpty()) {
			try {
				if (fileName.equals(FILENAME_TASK)) {
					Type collectionType = new TypeToken<TreeMap<Integer, Task>>() {
					}.getType();
					tasksCache = gson.fromJson(fileToTextBuffer.toString(),
							collectionType);
				} else if (fileName.equals(FILENAME_PROPERTIES)) {
					Type collectionType = new TypeToken<HashMap<String, Object>>() {
					}.getType();
					properties = gson.fromJson(fileToTextBuffer.toString(),
							collectionType);
				}
			} catch (JsonSyntaxException e) {
				logger.log(Level.SEVERE, e.toString());
				throw e;
			}
		}
	}

	private void writeChangesToFile(String fileName) {
		BufferedWriter writer;
		try {
			File fileToWrite = allFiles.get(fileName);
			writer = new BufferedWriter(new FileWriter(fileToWrite));
			if (fileName.equals(FILENAME_TASK)) {
				Type collectionType = new TypeToken<TreeMap<Integer, Task>>() {
				}.getType();
				writer.write(gson.toJson(tasksCache, collectionType));
			} else if (fileName.equals(FILENAME_PROPERTIES)) {
				Type collectionType = new TypeToken<HashMap<String, Object>>() {
				}.getType();
				writer.write(gson.toJson(properties, collectionType));
			}
			writer.close();
		} catch (IOException e) {
			logger.log(Level.SEVERE, e.toString());
		}
	}

	/**
	 * @param propertyName
	 *          the name of the property that was saved
	 * @return A string of property matched by the propertyName, or null if the
	 *         property doesn't exist
	 */
	public String getProperty(String propertyName) {
		return properties.get(propertyName);
	}

	/**
	 * @param propertyName
	 *          The name of the property to be saved.
	 * @param property
	 *          A string to be saved as a property.
	 */
	public void setProperty(String propertyName, String property) {
		properties.put(propertyName, property);
		this.writeChangesToFile(FILENAME_PROPERTIES);
	}

	/**
	 * 
	 * @param task
	 * @return generated taskId of successfully added task
	 * @throws DuplicateKeyException
	 *           task with same id is in the database
	 */
	public int addTask(Task newTask) throws DuplicateKeyException {
		// Supports for undoing deleted task
		if (newTask.getTaskId() != 0) {
			if (tasksCache.containsKey(newTask.getTaskId())) {
				throw new DuplicateKeyException(EXCEPTION_MSG_DUPLICATE_ID);
			}
			tasksCache.put(newTask.getTaskId(), newTask);
			this.writeChangesToFile(FILENAME_TASK);
			return newTask.getTaskId();
		}

		// Generate a new taskId to add a totally new task
		int newTaskIdGenerated;
		if (tasksCache.isEmpty()) {
			newTaskIdGenerated = 1;
		} else {
			newTaskIdGenerated = tasksCache.lastKey() + 1;
		}
		newTask.setTaskId(newTaskIdGenerated);
		tasksCache.put(newTaskIdGenerated, newTask);
		this.writeChangesToFile(FILENAME_TASK);
		return newTaskIdGenerated;
	}

	/**
	 * 
	 * @param taskId
	 *          taskId of the task to be deleted from the database
	 * @return true when deleted, or false if not found
	 */
	public boolean deleteTask(int taskId) {
		if (tasksCache.containsKey(taskId)) {
			tasksCache.remove(taskId);
			this.writeChangesToFile(FILENAME_TASK);
			return true;
		} else {
			return false;
		}
	}

	/**
	 * @param taskId
	 *          taskId of the task to check for existent in the database.
	 * @return returns true if the taskId is found, or false if not found
	 */
	public boolean containsTask(int taskId) {
		return tasksCache.containsKey(taskId);
	}

	/**
	 * @param taskId
	 *          taskId of the task that exist in the database.
	 * @return returns the task if the taskId is valid, or null if invalid
	 */
	public Task getTask(int taskId) {
		return tasksCache.get(taskId);
	}

	/**
	 * 
	 * @param taskToUpdate
	 *          The updated task to be written over the task in database
	 * @return true if Updated, false if not found
	 * @throws MissingFieldException
	 *           task identifier missing
	 */
	public boolean updateTask(Task taskToUpdate) throws Exception {
		int taskIdToUpdate = taskToUpdate.getTaskId();
		if (taskIdToUpdate == 0) {
			throw new MissingFieldException(EXCEPTION_MSG_MISSING_ID);
		}
		if (tasksCache.put(taskIdToUpdate, taskToUpdate) != null) {
			this.writeChangesToFile(FILENAME_TASK);
			return true;
		}
		return false;
	}

	/**
	 * @param startDay
	 *          Start of the time range of the tasks you want
	 * @param endDay
	 *          End of the time range of the tasks you want
	 * @return An arraylist of all the tasks within a given date range. An empty
	 *         arraylist will be returned if nothing is found.
	 * @throws InvalidDateRangeException
	 *           endDay cannot be strictly earlier than startDay
	 */
	public ArrayList<Task> retrieveTasks(DateTime startDay, DateTime endDay)
			throws InvalidDateRangeException {
		List<DeadlineTask> deadlineTasks = new ArrayList<DeadlineTask>();
		List<TimedTask> timedTasks = new ArrayList<TimedTask>();
		List<FloatingTask> floatingTasks = new ArrayList<FloatingTask>();
		LocalDate rangeStart = startDay.toLocalDate();
		LocalDate rangeEnd = endDay.toLocalDate();
		if (rangeEnd.isBefore(rangeStart)) {
			throw new InvalidDateRangeException(EXCEPTION_MSG_INVALID_DATE_RANGE);
		} else {
			for (Task taskInCache : tasksCache.values()) {
				if (taskInCache instanceof DeadlineTask) {
					DeadlineTask deadlineTask = (DeadlineTask) taskInCache;
					// Get the localdate only so that we can compare without time
					LocalDate deadline = deadlineTask.getDeadline().toLocalDate();
					if (isWithin(deadline, rangeStart, rangeEnd)) {
						deadlineTasks.add((DeadlineTask) taskInCache);
					}
				} else if (taskInCache instanceof TimedTask) {
					TimedTask timedTask = (TimedTask) taskInCache;
					// Get the localdate only so that we can compare without time
					LocalDate taskStart = timedTask.getStart().toLocalDate();
					LocalDate taskEnd = timedTask.getEnd().toLocalDate();

					if (isWithin(taskStart, taskEnd, rangeStart, rangeEnd)) {
						timedTasks.add(timedTask);
					}
				} else if (taskInCache instanceof FloatingTask) {
					floatingTasks.add((FloatingTask) taskInCache);
				}
			}
		}
		return combineTasksForViewing(deadlineTasks, timedTasks, floatingTasks);
	}

	/**
	 * @param startDay
	 *          Start of the time range of the tasks you want
	 * @param endDay
	 *          End of the time range of the tasks you want
	 * @param taskType
	 *          Only DeadlineTask, TimedTask and Floating task will be considered.
	 * @return An arraylist of a specific type of task within a given date range.
	 *         An empty arraylist will be returned if nothing is found or the
	 *         TaskType specified is incorrect.
	 * @throws InvalidDateRangeException
	 *           endDay cannot be strictly earlier than startDay
	 */
	public ArrayList<Task> retrieveTasks(DateTime startDay, DateTime endDay,
			TaskType taskType) throws InvalidDateRangeException {
		ArrayList<Task> selectedTasks = new ArrayList<Task>();
		LocalDate rangeStart = startDay.toLocalDate();
		LocalDate rangeEnd = endDay.toLocalDate();
		if (rangeEnd.isBefore(rangeStart)) {
			throw new InvalidDateRangeException(EXCEPTION_MSG_INVALID_DATE_RANGE);
		}
		for (Task taskInCache : tasksCache.values()) {
			switch (taskType) {
			// Only add the type of task that is needed
				case DEADLINE_TASK:
					if (taskInCache instanceof DeadlineTask) {
						DeadlineTask deadlineTask = (DeadlineTask) taskInCache;
						// Get the localdate only so that we can compare without time
						LocalDate deadline = deadlineTask.getDeadline().toLocalDate();
						if (isWithin(deadline, rangeStart, rangeEnd)) {
							selectedTasks.add(taskInCache);
						}
					}
					break;
				case TIMED_TASK:
					if (taskInCache instanceof TimedTask) {
						TimedTask timedTask = (TimedTask) taskInCache;
						// Get the localdate only so that we can compare without time
						LocalDate taskStart = timedTask.getStart().toLocalDate();
						LocalDate taskEnd = timedTask.getEnd().toLocalDate();

						if (isWithin(taskStart, taskEnd, rangeStart, rangeEnd)) {
							selectedTasks.add(timedTask);
						}
					}
					break;
				case FLOATING_TASK:
					if (taskInCache instanceof FloatingTask) {
						selectedTasks.add(taskInCache);
					}
			}
		}
		return selectedTasks;
	}

	/**
	 * 
	 * @return An arraylist of all the tasks in the system. An empty arraylist
	 *         will be returned if nothing is found.
	 */
	public ArrayList<Task> retrieveAll() {
		List<DeadlineTask> deadlineTasks = new ArrayList<DeadlineTask>();
		List<TimedTask> timedTasks = new ArrayList<TimedTask>();
		List<FloatingTask> floatingTasks = new ArrayList<FloatingTask>();
		for (Task taskInCache : tasksCache.values()) {
			if (taskInCache instanceof DeadlineTask) {
				deadlineTasks.add((DeadlineTask) taskInCache);
			} else if (taskInCache instanceof TimedTask) {
				timedTasks.add((TimedTask) taskInCache);
			} else if (taskInCache instanceof FloatingTask) {
				floatingTasks.add((FloatingTask) taskInCache);
			}
		}
		return combineTasksForViewing(deadlineTasks, timedTasks, floatingTasks);
	}

	/**
	 * 
	 * @param taskType
	 *          Only DeadlineTask, TimedTask and Floating task will be considered.
	 * @return An arraylist of all the specific type of tasks in the system. An
	 *         empty arraylist will be returned if nothing is found or if type of
	 *         task is incorrect.
	 */
	public ArrayList<Task> retrieveAll(TaskType taskType) {
		ArrayList<Task> selectedTasks = new ArrayList<Task>();
		for (Task taskInCache : tasksCache.values()) {
			switch (taskType) {
				case DEADLINE_TASK:
					if (taskInCache instanceof DeadlineTask) {
						selectedTasks.add(taskInCache);
					}
					break;
				case TIMED_TASK:
					if (taskInCache instanceof TimedTask) {
						selectedTasks.add(taskInCache);
					}
					break;
				case FLOATING_TASK:
					if (taskInCache instanceof FloatingTask) {
						selectedTasks.add(taskInCache);
					}
					break;

			}
		}
		return selectedTasks;
	}

	/**
	 * 
	 * @param searchCriteria
	 * @return An arraylist of all the tasks that meets the searching criteria. An
	 *         empty arraylist will be returned if nothing is found.
	 * @throws NullPointerException
	 *           searchCriteria is null
	 */
	public ArrayList<Task> retrieveContaining(String searchCriteria)
			throws NullPointerException {
		List<DeadlineTask> deadlineTasks = new ArrayList<DeadlineTask>();
		List<TimedTask> timedTasks = new ArrayList<TimedTask>();
		List<FloatingTask> floatingTasks = new ArrayList<FloatingTask>();
		for (Task taskInCache : tasksCache.values()) {
			if (taskInCache.getTitle().toUpperCase()
					.contains(searchCriteria.toUpperCase())
					|| taskInCache.getDescription().toUpperCase()
							.contains(searchCriteria.toUpperCase())) {
				if (taskInCache instanceof DeadlineTask) {
					deadlineTasks.add((DeadlineTask) taskInCache);
				} else if (taskInCache instanceof TimedTask) {
					timedTasks.add((TimedTask) taskInCache);
				} else if (taskInCache instanceof FloatingTask) {
					floatingTasks.add((FloatingTask) taskInCache);
				}
			}
		}
		return combineTasksForViewing(deadlineTasks, timedTasks, floatingTasks);

	}

	/**
	 * 
	 * @param searchCriteria
	 * @param taskType
	 *          Only DeadlineTask, TimedTask and Floating task will be considered.
	 * @return An arraylist of all the tasks that meets the searching criteria. An
	 *         empty arraylist will be returned if nothing is found.
	 * @throws NullPointerException
	 *           searchCriteria is null
	 */
	public ArrayList<Task> retrieveContaining(String searchCriteria,
			TaskType taskType) throws NullPointerException {
		ArrayList<Task> selectedTasks = new ArrayList<Task>();
		for (Task taskInCache : tasksCache.values()) {
			if (foundInTask(taskInCache, searchCriteria)) {
				switch (taskType) {
					case DEADLINE_TASK:
						if (taskInCache instanceof DeadlineTask) {
							selectedTasks.add(taskInCache);
						}
						break;
					case TIMED_TASK:
						if (taskInCache instanceof TimedTask) {
							selectedTasks.add(taskInCache);
						}
						break;
					case FLOATING_TASK:
						if (taskInCache instanceof FloatingTask) {
							selectedTasks.add(taskInCache);
						}
						break;

				}
			}
		}
		return selectedTasks;

	}

	/**
	 * @return true if searchCriteria is found in the name or description of the
	 *         task.
	 */
	private boolean foundInTask(Task task, String searchCriteria) {
		return (task.getTitle().toUpperCase()
				.contains(searchCriteria.toUpperCase()) || task.getDescription()
				.toUpperCase().contains(searchCriteria.toUpperCase()));
	}

	private ArrayList<Task> combineTasksForViewing(
			List<DeadlineTask> deadlineTasks, List<TimedTask> timedTasks,
			List<FloatingTask> floatingTasks) {
		ArrayList<Task> filteredTasks = new ArrayList<Task>();

		Collections.sort(deadlineTasks, DeadlineTask.COMPARE_BY_DATE);
		Collections.sort(timedTasks, TimedTask.COMPARE_BY_DATE);

		filteredTasks.addAll(deadlineTasks);
		filteredTasks.addAll(timedTasks);
		filteredTasks.addAll(floatingTasks);
		return filteredTasks;
	}

	/**
	 * @param taskStart
	 *          Start date of the task
	 * @param taskEnd
	 *          End date of the task
	 * @param rangeStart
	 *          Start of the range to check
	 * @param rangeEnd
	 *          End of the range to check
	 * @return true if a day between taskStart and taskEnd inclusively is within
	 *         rangeStart and rangeEnd
	 */
	private boolean isWithin(LocalDate taskStart, LocalDate taskEnd,
			LocalDate rangeStart, LocalDate rangeEnd) {
		return (!(taskStart.isAfter(rangeEnd) || taskStart.isBefore(rangeStart))
				|| !(taskEnd.isAfter(rangeEnd) || taskEnd.isBefore(rangeStart)) || taskStart
				.isBefore(rangeStart) && taskEnd.isAfter(rangeEnd));
	}

	/**
	 * @param dateToCheck
	 *          The date to check if within the given range.
	 * @param rangeStart
	 *          Start of the range to check
	 * @param rangeEnd
	 *          End of the range to check
	 * @return true if the day is within rangeStart and rangeEnd
	 */
	private boolean isWithin(LocalDate dateToCheck, LocalDate rangeStart,
			LocalDate rangeEnd) {
		return (!dateToCheck.isBefore(rangeStart) && !dateToCheck.isAfter(rangeEnd));
	}

}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\DbController.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\DbControllerATD.java
	 */

package typetodo.db;

import static org.junit.Assert.assertEquals;

import org.joda.time.DateTime;
import org.junit.Test;

import typetodo.model.FloatingTask;

public class DbControllerATD {
	/**
	 * Note: Every test assumes starting with clean state. Please make sure the
	 * savedfiles folder does not exist or the files are empty files before
	 * starting the test. This is required as the DbController needs to handle the
	 * file directly.
	 */

	@Test
	public void PropertyTest() {
		DbController db;
		try {
			db = DbController.getInstance();
			/**
			 * Test for property name: Method is not tested extensively and max length
			 * string is not tested as Java's implementation of HashMap is assumed to
			 * be well-tested.
			 * 
			 */
			final String dummyProperty = "PROPERTY";
			// Boundary case for 'empty' property name partition
			db.setProperty("", dummyProperty);
			assertEquals("Empty property name in memory", dummyProperty,
					db.getProperty(""));
			db.reloadAllFiles();
			assertEquals("Empty property name in file", dummyProperty,
					db.getProperty(""));

			// Boundary cases for property name of 'positive length' partition
			// property name of length 1
			db.setProperty("1", dummyProperty);
			assertEquals("property name of size 1 in memory", dummyProperty,
					db.getProperty("1"));
			db.reloadAllFiles();
			assertEquals("property name of size 1 in file", dummyProperty,
					db.getProperty("1"));
			// property name of length 2
			db.setProperty("02", dummyProperty);
			assertEquals("property name of size 2 in memory", dummyProperty,
					db.getProperty("02"));
			db.reloadAllFiles();
			assertEquals("property name of size 2 in file", dummyProperty,
					db.getProperty("02"));

			/**
			 * Test for property string: Method is not tested extensively and max
			 * length string is not tested as Java's implementation of HashMap is
			 * assumed to be well-tested.
			 */
			// Boundary case for 'empty' property String partition
			final String nameEmpty = "EMPTY";
			db.setProperty(nameEmpty, new String());
			assertEquals("Empty property in memory", "", db.getProperty(nameEmpty));
			db.reloadAllFiles();
			assertEquals("Empty property in file", "", db.getProperty(nameEmpty));

			// Boundary case for property String of 'positive length' partition
			// property String of length of a datetime
			final String nameDateTime = "DATETIME";
			final DateTime timeProperty = new DateTime(
					"2013-01-01T00:00:00.000+08:00");
			db.setProperty(nameDateTime, timeProperty.toString());
			assertEquals("DateTime property in memory.", timeProperty.toString(),
					db.getProperty(nameDateTime));
			db.reloadAllFiles();
			assertEquals("DateTime property in file", timeProperty.toString(),
					db.getProperty(nameDateTime));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	public void TaskHandlingTest() {
		DbController db;
		try {
			FloatingTask floatingTask1 = new FloatingTask("floatingTask1", "Desc");
			FloatingTask floatingTask2 = new FloatingTask("floatingTask2", "Desc");
			FloatingTask floatingTask3 = new FloatingTask("floatingTask3", "Desc");
			db = DbController.getInstance();
			/**
			 * Test for adding first 3 tasks and the generation of taskId
			 */
			// There is only 1 partition
			assertEquals("taskId 1 not generated", 1, db.addTask(floatingTask1));
			assertEquals("taskId 2 not generated", 2, db.addTask(floatingTask2));
			assertEquals("taskId 3 not generated", 3, db.addTask(floatingTask3));

			/**
			 * Test for retrievals and deletion when there are 3 tasks in the database
			 */
			// Boundary cases for retrieval of 'taskId larger than largest taskId in
			// database' partition
			assertEquals("retrieve of id greater by 1", null, db.getTask(4));
			assertEquals("retrieve of id greater by 2", null, db.getTask(5));
			assertEquals("retrieve of id of value max int", null,
					db.getTask(Integer.MAX_VALUE));
			// Boundary case for retrieval of 'taskId smaller than smallest' partition
			assertEquals("retrieve of id 0", null, db.getTask(0));
			// Boundary cases for retrieval of 'negative taskId' partition
			assertEquals("retrieve of id -1", null, db.getTask(-1));
			assertEquals("retrieve of id -2", null, db.getTask(-2));
			assertEquals("retrieve of id -3", null, db.getTask(-3));
			// Boundary cases for retrieval of 'taskId in database' partition
			assertEquals("retrieve of id 1", floatingTask1, db.getTask(1));
			assertEquals("retrieve of id 2", floatingTask2, db.getTask(2));
			assertEquals("retrieve of id 3", floatingTask3, db.getTask(3));
			// Boundary cases for deletion of 'taskId larger than the largest taskId
			// in database' partition
			assertEquals("deletion of id greater by 1", false, db.deleteTask(4));
			assertEquals("deletion of id greater by 2", false, db.deleteTask(5));
			assertEquals("deletion of id of value max int", false,
					db.deleteTask(Integer.MAX_VALUE));
			// Boundary case for deletion of 'taskId smaller than smallest' partition
			assertEquals("deletion of id 0", false, db.deleteTask(0));
			// Boundary cases for deletion of 'negative taskId' partition
			assertEquals("deletion of id -1", false, db.deleteTask(-1));
			assertEquals("deletion of id -2", false, db.deleteTask(-2));
			assertEquals("deletion of id -3", false, db.deleteTask(-3));
			// Boundary case for deletion of 'taskId in database' partition
			assertEquals("deletion of id 1", true, db.deleteTask(1));

			/**
			 * Test for retrievals and deletion when there are 2 tasks in the database
			 */
			// Boundary cases for retrieval of 'taskId larger than largest taskId in
			// database' partition
			assertEquals("retrieve of id greater by 1", null, db.getTask(4));
			assertEquals("retrieve of id greater by 2", null, db.getTask(5));
			assertEquals("retrieve of id of value max int", null,
					db.getTask(Integer.MAX_VALUE));
			// Boundary case for retrieval of 'taskId smaller than smallest' partition
			assertEquals("retrieve of id 1", null, db.getTask(1));
			assertEquals("retrieve of id 0", null, db.getTask(0));
			// Boundary cases for retrieval of 'negative taskId' partition
			assertEquals("retrieve of id -1", null, db.getTask(-1));
			assertEquals("retrieve of id -2", null, db.getTask(-2));
			assertEquals("retrieve of id -3", null, db.getTask(-3));
			// Boundary cases for retrieval of 'taskId in database' partition
			assertEquals("retrieve of id 2", floatingTask2, db.getTask(2));
			assertEquals("retrieve of id 3", floatingTask3, db.getTask(3));
			// Boundary cases for deletion of 'taskId larger than the largest taskId
			// in database' partition
			assertEquals("deletion of id greater by 1", false, db.deleteTask(4));
			assertEquals("deletion of id greater by 2", false, db.deleteTask(5));
			assertEquals("deletion of id of value max int", false,
					db.deleteTask(Integer.MAX_VALUE));
			// Boundary case for deletion of 'taskId smaller than smallest' partition
			assertEquals("deletion of id 1", false, db.deleteTask(1));
			assertEquals("deletion of id 0", false, db.deleteTask(0));
			// Boundary cases for deletion of 'negative taskId' partition
			assertEquals("deletion of id -1", false, db.deleteTask(-1));
			assertEquals("deletion of id -2", false, db.deleteTask(-2));
			assertEquals("deletion of id -3", false, db.deleteTask(-3));
			// Boundary case for deletion of 'taskId in database' partition
			assertEquals("deletion of id 3", true, db.deleteTask(3));

			/**
			 * Test for retrievals and deletion when there is only taskId 2 in the
			 * database
			 */
			// Boundary cases for retrieval of 'taskId larger than largest taskId in
			// database' partition
			assertEquals("retrieve of id greater by 1", null, db.getTask(3));
			assertEquals("retrieve of id greater by 2", null, db.getTask(4));
			assertEquals("retrieve of id of value max int", null,
					db.getTask(Integer.MAX_VALUE));
			// Boundary case for retrieval of 'taskId smaller than smallest' partition
			assertEquals("retrieve of id 1", null, db.getTask(1));
			assertEquals("retrieve of id 0", null, db.getTask(0));
			// Boundary cases for retrieval of 'negative taskId' partition
			assertEquals("retrieve of id -1", null, db.getTask(-1));
			assertEquals("retrieve of id -2", null, db.getTask(-2));
			assertEquals("retrieve of id -3", null, db.getTask(-3));
			// Boundary cases for retrieval of 'taskId in database' partition
			assertEquals("retrieve of id 2", floatingTask2, db.getTask(2));
			// Boundary cases for deletion of 'taskId larger than the largest taskId
			// in database' partition
			assertEquals("deletion of id greater by 1", false, db.deleteTask(3));
			assertEquals("deletion of id greater by 2", false, db.deleteTask(4));
			assertEquals("deletion of id of value max int", false,
					db.deleteTask(Integer.MAX_VALUE));
			// Boundary case for deletion of 'taskId smaller than smallest' partition
			assertEquals("deletion of id 1", false, db.deleteTask(1));
			assertEquals("deletion of id 0", false, db.deleteTask(0));
			// Boundary cases for deletion of 'negative taskId' partition
			assertEquals("deletion of id -1", false, db.deleteTask(-1));
			assertEquals("deletion of id -2", false, db.deleteTask(-2));
			assertEquals("deletion of id -3", false, db.deleteTask(-3));
			// Boundary case for deletion of 'taskId in database' partition
			assertEquals("deletion of id 2", true, db.deleteTask(2));

			/**
			 * Test for retrievals and deletion when all tasks are deleted from the
			 * database
			 */
			// Boundary cases for retrieval of 'taskId of positive value' partition
			assertEquals("retrieve of id 1", null, db.getTask(1));
			assertEquals("retrieve of id 2", null, db.getTask(2));
			assertEquals("retrieve of id of value max int", null,
					db.getTask(Integer.MAX_VALUE));
			// Boundary case for retrieval of 'taskId == 0' partition
			assertEquals("retrieve of id 0", null, db.getTask(0));
			// Boundary cases for retrieval of 'negative taskId' partition
			assertEquals("retrieve of id -1", null, db.getTask(-1));
			assertEquals("retrieve of id -2", null, db.getTask(-2));
			assertEquals("retrieve of id -3", null, db.getTask(-3));
			// Boundary cases for deletion of 'taskId of positive value' partition
			assertEquals("deletion of id 1", false, db.deleteTask(1));
			assertEquals("deletion of id 2", false, db.deleteTask(2));
			assertEquals("deletion of id of value max int", false,
					db.deleteTask(Integer.MAX_VALUE));
			// Boundary case for deletion of 'taskId == 0' partition
			assertEquals("deletion of id 0", false, db.deleteTask(0));
			// Boundary cases for deletion of 'negative taskId' partition
			assertEquals("deletion of id -1", false, db.deleteTask(-1));
			assertEquals("deletion of id -2", false, db.deleteTask(-2));
			assertEquals("deletion of id -3", false, db.deleteTask(-3));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\DbControllerATD.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\TaskAdapter.java
	 */

package typetodo.db;

import java.lang.reflect.Type;

import typetodo.model.Task;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class TaskAdapter implements JsonSerializer<Task>,
		JsonDeserializer<Task> {
	@Override
	public JsonElement serialize(Task src, Type typeOfSrc,
			JsonSerializationContext context) {
		JsonObject result = new JsonObject();
		result.add("type", new JsonPrimitive(src.getClass().getSimpleName()));
		result.add("properties", context.serialize(src, src.getClass()));

		return result;
	}

	@Override
	public Task deserialize(JsonElement json, Type typeOfT,
			JsonDeserializationContext context) throws JsonParseException {
		JsonObject jsonObject = json.getAsJsonObject();
		String type = jsonObject.get("type").getAsString();
		JsonElement element = jsonObject.get("properties");

		try {
			return context.deserialize(element,
					Class.forName("typetodo.model." + type));
		} catch (ClassNotFoundException e) {
			throw new JsonParseException("Unknown element type: " + type, e);
		}
	}

}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\db\TaskAdapter.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\model\TaskType.java
	 */

package typetodo.model;

public enum TaskType {
	DEADLINE_TASK, FLOATING_TASK, TIMED_TASK
}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\model\TaskType.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\CommandPanel.java
	 */

package typetodo.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.LayoutManager;
import java.awt.RenderingHints;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowEvent;
import java.awt.geom.RoundRectangle2D;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;

@SuppressWarnings("serial")
public class CommandPanel extends JPanel {
	private JLabel lblTitle;
	private JLabel lblMinimize;
	private JLabel lblClose;
	private JTextField txtCmd;

	/**
	 * 
	 */
	public CommandPanel() {
		super();
		initialize();
		this.setLayout(new FlowLayout(FlowLayout.CENTER));
	}

	/**
	 * @param isDoubleBuffered
	 */
	public CommandPanel(boolean isDoubleBuffered) {
		super(isDoubleBuffered);
		initialize();
	}

	/**
	 * @param layout
	 * @param isDoubleBuffered
	 */
	public CommandPanel(LayoutManager layout, boolean isDoubleBuffered) {
		super(layout, isDoubleBuffered);
		initialize();
		this.setLayout(layout);
	}

	/**
	 * @param layout
	 */
	public CommandPanel(LayoutManager layout) {
		super(layout);
		initialize();
		this.setLayout(layout);
	}

	private void initialize() {
		lblTitle = new JLabel(" TypeToDo ");
		lblMinimize = new JLabel("-");
		lblMinimize.setToolTipText("Minimize");
		lblClose = new JLabel("X");
		lblClose.setToolTipText("Close");
		txtCmd = new JTextField(30);
		txtCmd.setToolTipText("Enter a command");

		this.add(lblTitle);
		this.add(txtCmd);
		this.add(lblMinimize);
		this.add(lblClose);

		this.setBackground(new Color(0, 0, 0, 0));
		this.setMinimumSize(getSize());
		this.setVisible(true);
	}

	@Override
	protected void paintComponent(Graphics g) {
		super.paintComponent(g);
		// JFrame parentFrame = (JFrame) SwingUtilities.getWindowAncestor(this);
		Graphics2D g2d = (Graphics2D) g;
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);

		g2d.setPaint(new Color(230, 230, 230));
		g2d.fill(new RoundRectangle2D.Double(0, 0, getWidth(), getHeight(), 20, 20));
	}

	@Override
	public Component add(Component comp) {
		comp.setFont(new Font(Font.SANS_SERIF, Font.PLAIN,
				comp.getFont().getSize() + 5));
		return super.add(comp);
	}

	protected void setFrameToMinimize(final Frame parent) {
		lblMinimize.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent evt) {
				parent.setState(JFrame.ICONIFIED);
			}
		});
	}

	protected void setFrameToClose(final Frame parent) {
		lblClose.addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent evt) {
				parent
						.dispatchEvent(new WindowEvent(parent, WindowEvent.WINDOW_CLOSING));
			}
		});
	}

	public JTextField getTxtCmd() {
		return txtCmd;
	}

}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\CommandPanel.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\FeedbackDialog.java
	 */

package typetodo.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.geom.RoundRectangle2D;
import java.util.Scanner;

import javax.swing.AbstractAction;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextPane;
import javax.swing.KeyStroke;
import javax.swing.text.BadLocationException;

public class FeedbackDialog extends JDialog {

	private JPanel feedbackPanel;
	private JPanel taskListPanel;
	private JTextArea txtFeedback;
	private JTextPane txtListOutput;
	private JScrollPane scrollableDisplay;
	public final static Color dialogColor = new Color(230, 230, 230);

	private static final String MESSAGE_NO_TASK = "Start using TypeToDo by typing "
			+ "<font color=\"#FF0000\">\"add your task;\"</font> now!";

	public FeedbackDialog() {
		super();
		initialize();
	}

	/**
	 * @param owner
	 * @param modal
	 */
	public FeedbackDialog(Frame owner, boolean modal) {
		super(owner, modal);
		setMinimumSize(new Dimension(owner.getWidth() - 40, 0));
		initialize();
	}

	/**
	 * @param owner
	 * @param title
	 * @param modal
	 * @param gc
	 */
	public FeedbackDialog(Frame owner, String title, boolean modal,
			GraphicsConfiguration gc) {
		super(owner, title, modal, gc);
		setMinimumSize(new Dimension(owner.getWidth() - 40, 50));
		initialize();
	}

	/**
	 * @param owner
	 * @param title
	 * @param modal
	 */
	public FeedbackDialog(Frame owner, String title, boolean modal) {
		super(owner, title, modal);
		setMinimumSize(new Dimension(owner.getWidth() - 40, 50));
		initialize();
	}

	/**
	 * @param owner
	 * @param title
	 */
	public FeedbackDialog(Frame owner, String title) {
		super(owner, title);
		setMinimumSize(new Dimension(owner.getWidth() - 40, 50));
		initialize();
	}

	/**
	 * @param owner
	 */
	public FeedbackDialog(Frame owner) {
		super(owner);
		setMinimumSize(new Dimension(owner.getWidth() - 40, 50));
		initialize();
	}

	public void setFeedbackText(String text) {
		this.txtFeedback.setText(text);
		this.pack();
	}

	public void setTableOfTasks(String htmlText) {
		String displayText;
		if (htmlText.isEmpty()) {
			displayText = MESSAGE_NO_TASK;
		} else {
			displayText = htmlText;
		}
		this.txtListOutput.setText(displayText);

		try {
			String textWithoutHtmlTags = txtListOutput.getDocument().getText(0,
					txtListOutput.getDocument().getLength());
			int indexToScrollTo = getIndexToScrollTo(displayText, textWithoutHtmlTags);
			txtListOutput.setCaretPosition(indexToScrollTo);
		} catch (BadLocationException e) {
			e.printStackTrace();
		}

		int textHeight = getTextHeight(displayText);
		int windowWidth = getMinimumSize().width;
		if (textHeight > 250) {
			scrollableDisplay.setPreferredSize(new Dimension(windowWidth, 250));
		} else {
			scrollableDisplay
					.setPreferredSize(new Dimension(windowWidth, textHeight));
		}
		this.pack();
	}

	private int getTextHeight(String text) {
		// A surrogate JTextPane is used in place of the actual JTextPane due to the
		// eccentric behavior with JTextPane
		JTextPane surrogate = new JTextPane();
		surrogate.setContentType("text/html");
		surrogate.setMinimumSize(new Dimension(txtListOutput.getWidth(), 0));
		surrogate.setMaximumSize(new Dimension(txtListOutput.getWidth(), 20));
		JPanel surrogatePanel = new JPanel(new BorderLayout());
		surrogatePanel.add(surrogate, BorderLayout.NORTH);
		surrogate.setText(text);
		surrogatePanel.revalidate();
		return surrogatePanel.getPreferredSize().height;
	}

	public int getIndexToScrollTo(String htmlText, String textWithOutHtmlTags) {
		int indexOfMarker = htmlText.indexOf("<marker>");

		if (indexOfMarker != -1) {
			String startOfTask = htmlText.substring(htmlText.indexOf("<marker>"),
					htmlText.length());
			String idOfTask = "";
			idOfTask = startOfTask.substring(startOfTask.indexOf("["),
					startOfTask.length());

			Scanner sc = new Scanner(idOfTask);
			sc.useDelimiter("]");
			idOfTask = sc.next() + "]";
			System.out.println(idOfTask);
			sc.close();

			return textWithOutHtmlTags.indexOf(idOfTask);
		}

		return 0;
	}

	@Override
	public boolean requestFocusInWindow() {
		// The scrollableDisplay will be the first component that require focus in
		// this dialog
		return scrollableDisplay.requestFocusInWindow();
	}

	/**
	 * 
	 */
	public void initialize() {
		this.setUndecorated(true);
		feedbackPanel = new JPanel(new FlowLayout(FlowLayout.LEFT)) {
			@Override
			protected void paintComponent(Graphics g) {
				super.paintComponent(g);
				Graphics2D g2d = (Graphics2D) g;
				g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
						RenderingHints.VALUE_ANTIALIAS_ON);

				g2d.setPaint(Color.DARK_GRAY);
				g2d.fill(new RoundRectangle2D.Double(0, -10, getWidth(),
						getHeight() + 10, 20, 20));
			}
		};
		txtFeedback = new JTextArea();
		txtFeedback.setForeground(Color.WHITE);
		txtFeedback.setBackground(Color.DARK_GRAY);
		txtFeedback.setLineWrap(true);
		txtFeedback.setWrapStyleWord(true);
		txtFeedback.setSize(this.getMinimumSize());
		txtFeedback.setMinimumSize(new Dimension(txtFeedback.getWidth(), 0));
		txtFeedback.setMaximumSize(new Dimension(txtFeedback.getWidth(), 20));
		txtFeedback.setEditable(false);
		feedbackPanel.add(txtFeedback);

		taskListPanel = new JPanel(new BorderLayout());
		txtListOutput = new JTextPane();
		txtListOutput.setContentType("text/html");
		txtListOutput.setBackground(dialogColor);
		txtListOutput.setEditable(false);
		txtListOutput.setSize(this.getMinimumSize());
		txtListOutput.setMinimumSize(new Dimension(txtListOutput.getWidth(), 0));
		txtListOutput.setMaximumSize(new Dimension(txtListOutput.getWidth(), 20));
		taskListPanel.setBackground(dialogColor);

		scrollableDisplay = new JScrollPane(txtListOutput);
		scrollableDisplay.setBorder(null);
		scrollableDisplay
				.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		scrollableDisplay
				.setPreferredSize(new Dimension(getMinimumSize().width, 0));
		taskListPanel.add(scrollableDisplay, BorderLayout.NORTH);

		scrollableDisplay.getInputMap().put(
				KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), "navDown");
		scrollableDisplay.getActionMap().put("navDown", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				JScrollBar vertical = scrollableDisplay.getVerticalScrollBar();
				vertical.setValue(vertical.getValue() + scrollableDisplay.getHeight());
			}
		});
		scrollableDisplay.getInputMap().put(
				KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), "navUp");
		scrollableDisplay.getActionMap().put("navUp", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				JScrollBar vertical = scrollableDisplay.getVerticalScrollBar();
				vertical.setValue(vertical.getValue() - scrollableDisplay.getHeight());
			}
		});

		this.setBackground(dialogColor);
		this.setLayout(new BorderLayout());
		this.add(feedbackPanel, BorderLayout.NORTH);
		this.add(taskListPanel, BorderLayout.CENTER);
		this.pack();
	}

}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\FeedbackDialog.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\TypeToDoGui.java
	 */


package typetodo.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.net.URL;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.LinkedList;

import javax.swing.AbstractAction;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;
import javax.swing.border.EmptyBorder;

import org.jnativehook.GlobalScreen;
import org.jnativehook.NativeHookException;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;

import typetodo.logic.MainController;
import typetodo.logic.Schedule;

public class TypeToDoGui extends JFrame implements View, NativeKeyListener,
		WindowListener {

	public static final String IMAGE_DIRECTORY = "images/";
	public static final String FILENAME_LOGO = "logo.png";
	private static final String MESSAGE_ERROR_INITIALIZING = "There is an error initializing the scheduler. Please make sure to download the latest version.";
	private static final String MESSAGE_ERROR_NATIVE_HOOK = "There was a problem registering the global hotkey.\n"
			+ "For mavericks OSX users:\n"
			+ "Please go to Preferences>Security & Privacy>Privacy>Acessibility to allow Jar Launcher.";

	private static TypeToDoGui mainGui;
	private final CommandPanel cmdPanel;
	private final JTextField txtCmd;
	private final FeedbackDialog feedbackDialog;
	private Image imgLogo;
	private LinkedList<String> inputHistory;
	private int historyIndex;

	private static MainController sc;

	private TypeToDoGui() {

		inputHistory = new LinkedList<String>();

		this.setUndecorated(true);
		this.setLayout(new BorderLayout());
		this.setBackground(new Color(0, 0, 0, 0));
		this.setAlwaysOnTop(true);
		addWindowListener(this);
		this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

		URL imgLogoUrl = TypeToDoGui.class.getResource(IMAGE_DIRECTORY
				+ FILENAME_LOGO);
		if (imgLogoUrl != null) {
			imgLogo = Toolkit.getDefaultToolkit().getImage(imgLogoUrl);
			this.setIconImage(imgLogo);
		}

		cmdPanel = new CommandPanel();
		cmdPanel.setFrameToMinimize(this);
		cmdPanel.setFrameToClose(this);
		cmdPanel.setBorder(new EmptyBorder(0, 5, 0, 5));
		this.add(cmdPanel);
		this.pack();
		// This will center the JFrame in the middle of the screen
		this.setLocationRelativeTo(null);

		feedbackDialog = new FeedbackDialog(this);
		feedbackDialog.setLocationRelativeTo(this);
		feedbackDialog.setLocation(feedbackDialog.getX(),
				this.getY() + this.getHeight());
		feedbackDialog.pack();
		feedbackDialog.setVisible(true);

		WindowMoveAdapter wma = WindowMoveAdapter.getInstance();
		this.addMouseListener(wma);
		this.addMouseMotionListener(wma);
		wma.addComponentToMove(this);
		feedbackDialog.addMouseListener(wma);
		feedbackDialog.addMouseMotionListener(wma);
		wma.addComponentToMove(feedbackDialog);

		// TypeToDoGui handles the components that involves knowledge of
		// ScheduleController to ensure only TypeToDoGui has the knowledge of
		// ScheduleController
		txtCmd = cmdPanel.getTxtCmd();
		txtCmd.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				String input = txtCmd.getText();
				if (!input.isEmpty()) {
					sc.parseAndExecute(input);
					if (historyIndex != 0) {
						// The user had navigated into the history, thus we need to clear
						// history.
						inputHistory.pop();
						historyIndex = 0; // Reset
					}
					addToHistory(input);
					txtCmd.setText("");
				}
			}

		});
		txtCmd.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0),
				"traverseBackInHistory");
		txtCmd.getActionMap().put("traverseBackInHistory", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				String history;
				if (historyIndex == 0) {
					addToHistory(txtCmd.getText());
				}
				if (historyIndex < inputHistory.size() - 1) {
					historyIndex++;
					history = inputHistory.get(historyIndex);
					txtCmd.setText(history);
					if (history.contains(" ")) {
						txtCmd.select(history.indexOf(' ') + 1, history.length());
					}
				}
			}
		});
		txtCmd.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0),
				"traverseFrontInHistory");
		txtCmd.getActionMap().put("traverseFrontInHistory", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				String history;
				if (historyIndex > 0) {
					historyIndex--;
					if (historyIndex == 0) {
						// Remove the last input that the user has not execute
						history = inputHistory.pop();
					} else {
						history = inputHistory.get(historyIndex);
					}
					txtCmd.setText(history);
					if (history.contains(" ")) {
						txtCmd.select(history.indexOf(' ') + 1, history.length());
					}
				}
			}
		});
		txtCmd.getInputMap()
				.put(
						KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE,
								KeyEvent.CTRL_DOWN_MASK), "undo");
		txtCmd.getActionMap().put("undo", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				// Hotkey represents user typing undo
				sc.parseAndExecute("undo");
			}
		});
		txtCmd.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),
				"moveToDialog");
		txtCmd.getActionMap().put("moveToDialog", new AbstractAction() {
			public void actionPerformed(ActionEvent e) {
				feedbackDialog.toFront();
				feedbackDialog.requestFocusInWindow();
			}
		});

		this.setVisible(true);
		txtCmd.requestFocusInWindow();
	}

	public static TypeToDoGui getInstance() {
		if (mainGui == null) {
			mainGui = new TypeToDoGui();
		}
		return mainGui;
	}

	@Override
	public void windowOpened(WindowEvent e) {
		// Initialze native hook.
		try {
			GlobalScreen.registerNativeHook();
		} catch (NativeHookException ex) {
			this.setAlwaysOnTop(false);
			JOptionPane.showMessageDialog(null, MESSAGE_ERROR_NATIVE_HOOK);
			this.setAlwaysOnTop(true);
			ex.printStackTrace();
		}

		GlobalScreen.getInstance().addNativeKeyListener(this);
	}

	public void windowClosed(WindowEvent e) {
		// Clean up the native hook.
		GlobalScreen.unregisterNativeHook();
		System.runFinalization();
		System.exit(0);
	}

	public void windowClosing(WindowEvent e) { /* Unimplemented */
	}

	public void windowIconified(WindowEvent e) { /* Unimplemented */
	}

	public void windowDeiconified(WindowEvent e) {
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				toFront();
				txtCmd.requestFocusInWindow();
			}
		});
	}

	public void windowActivated(WindowEvent e) { /* Unimplemented */
	}

	public void windowDeactivated(WindowEvent e) { /* Unimplemented */
	}

	@Override
	public void nativeKeyReleased(NativeKeyEvent e) {
		if (e.getKeyCode() == NativeKeyEvent.VK_SPACE
				&& e.getModifiers() == NativeKeyEvent.CTRL_MASK) {
			if (getExtendedState() == JFrame.ICONIFIED) {
				setExtendedState(JFrame.NORMAL);
			} else {
				setExtendedState(JFrame.ICONIFIED);
			}
		} else if (e.getKeyCode() == NativeKeyEvent.VK_F4
				&& e.getModifiers() == NativeKeyEvent.ALT_MASK) {
			dispatchEvent(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
		} else if (getExtendedState() == JFrame.NORMAL) {
			if (!txtCmd.hasFocus()
					&& (e.getKeyCode() == NativeKeyEvent.VK_I || e.getKeyCode() == NativeKeyEvent.VK_ENTER)) {
				toFront();
				txtCmd.requestFocusInWindow();
			}
		}
	}

	@Override
	public void nativeKeyPressed(NativeKeyEvent e) { /* Unimplemented */
	}

	@Override
	public void nativeKeyTyped(NativeKeyEvent e) { /* Unimplemented */
		if (e.getKeyCode() == NativeKeyEvent.VK_I) {
			if (getExtendedState() == JFrame.NORMAL && !txtCmd.hasFocus()) {
				txtCmd.requestFocusInWindow();
				System.out.println(e.getKeyChar());
			}
		}
	}

	/**
	 * @param input
	 *          We want to record a maximum of 50 histories so as not to waste
	 *          memory.
	 */
	private void addToHistory(String input) {
		if (inputHistory.size() > 50) {
			inputHistory.pollLast();
		}
		inputHistory.push(input);
	}

	@Override
	public boolean disableInput() {
		txtCmd.setEnabled(false);
		return !txtCmd.isEnabled();
	}

	@Override
	public boolean enableInput() {
		txtCmd.setEnabled(true);
		return txtCmd.isEnabled();
	}

	@Override
	public void displayFeedBack(String feedBack) {
		feedbackDialog.setFeedbackText(feedBack);
	}

	@Override
	public void displayErrorMessage(String errorMessage) {
		feedbackDialog.setFeedbackText(errorMessage);
	}

	@Override
	public void displayTasks(String tasks) {
		feedbackDialog.setTableOfTasks(tasks.trim());
	}

	@Override
	public void displayHelp(String helpMessage) {
		System.out.println(helpMessage);
		feedbackDialog.setTableOfTasks(helpMessage);
	}

	private static File f;
	private static FileChannel channel;
	private static FileLock lock;

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) {
		try {
			f = new File("RingOnRequest.lock");
			// Check if the lock exist
			if (f.exists()) {
				// if exist try to delete it
				f.delete();
			}
			// Try to get the lock
			channel = new RandomAccessFile(f, "rw").getChannel();
			lock = channel.tryLock();
			if (lock == null) {
				// File is lock by other application
				channel.close();

				throw new RuntimeException("Only 1 instance of TypeToDo can run.");
			}
			// Add shutdown hook to release lock when application shutdown
			ShutdownHook shutdownHook = new ShutdownHook();
			Runtime.getRuntime().addShutdownHook(shutdownHook);

			SwingUtilities.invokeLater(new Runnable() {
				public void run() {
					TypeToDoGui cmdFrame = new TypeToDoGui();
					try {
						sc = new MainController(cmdFrame, new Schedule());
					} catch (IOException e) {
						cmdFrame.setAlwaysOnTop(false);
						JOptionPane.showMessageDialog(null, MESSAGE_ERROR_INITIALIZING);
						e.printStackTrace();
						System.exit(0);
					}
				}
			});
			try {
				Thread.sleep(10000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}

		} catch (IOException e) {
			throw new RuntimeException("Could not start process.", e);
		}
	}

	public static void unlockFile() {
		// release and delete file lock
		try {
			if (lock != null) {
				lock.release();
				channel.close();
				f.delete();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	static class ShutdownHook extends Thread {

		public void run() {
			unlockFile();
		}
	}
}

	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\TypeToDoGui.java





	/**
	 * origin: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\WindowMoveAdapter.java
	 */

package typetodo.ui;

import java.awt.Component;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.SwingUtilities;

public class WindowMoveAdapter extends MouseAdapter {
	private final List<Component> WindowMoveComponents;
	private static WindowMoveAdapter instance;
	private boolean dragging = false;
	private int prevX = -1;
	private int prevY = -1;

	private WindowMoveAdapter() {
		super();
		WindowMoveComponents = new ArrayList<Component>();
	}

	public static WindowMoveAdapter getInstance() {
		if (instance == null) {
			instance = new WindowMoveAdapter();
		}
		return instance;
	}

	public void addComponentToMove(Component component) {
		WindowMoveComponents.add(component);
	}

	public void mousePressed(MouseEvent e) {
		if (SwingUtilities.isLeftMouseButton(e)) {
			dragging = true;
		}
		prevX = e.getXOnScreen();
		prevY = e.getYOnScreen();
	}

	public void mouseDragged(MouseEvent e) {
		if (prevX != -1 && prevY != -1 && dragging) {
			int xMoved = e.getXOnScreen() - prevX;
			int yMoved = e.getYOnScreen() - prevY;
			for (Component window : WindowMoveComponents) {
				if (window != null && window.isShowing()) {
					Rectangle rect = window.getBounds();
					window.setBounds(rect.x + (xMoved), rect.y + (yMoved), rect.width,
							rect.height);
				}
			}
		}
		prevX = e.getXOnScreen();
		prevY = e.getYOnScreen();
	}

	public void mouseReleased(MouseEvent e) {
		dragging = false;
	}
}
	// End of segment: C:\Users\Shiyu\workspace\cs2103aug2013-w11-2j\src\typetodo\ui\WindowMoveAdapter.java





